---
name: "Async Design Patterns"
description: "Common async processing patterns and templates"
version: "1.0"
author: "Robert"
priority: 1
globs:
  - "src/**/*.py"
  - "tests/**/*.py"
  - "*.py"
triggers:
  - file_change
  - file_create
  - code_review
category: "async_patterns"
---

# Async Processing Patterns

## Batch Processing

**1. Async Batch Processing with Progress**
- **Type:** `design_pattern`
- **Condition:** `batch_processing`
- **Action:** `use_async_pattern`
- **Message:**
  When implementing batch processing operations:
  1. Use asyncio with aiohttp for concurrent processing
  2. Implement progress tracking with tqdm
  3. Use asyncio.as_completed for immediate results processing
  
  **Template:**
  ```python
  async def process_batch(items):
      async with aiohttp.ClientSession() as session:
          tasks = [process_single_item(session, item) for item in items]
          
          results = []
          with tqdm(total=len(tasks), desc="Processing items") as pbar:
              for coro in asyncio.as_completed(tasks):
                  result = await coro
                  results.append(result)
                  pbar.update(1)
          return results
  ```

  **Dependencies:**
  ```python
  import asyncio
  import aiohttp
  from tqdm import tqdm
  ```

**2. Rate Limited Processing**
- **Type:** `design_pattern`
- **Condition:** `rate_limiting`
- **Action:** `use_rate_limiter`
- **Message:**
  When implementing rate-limited operations:
  1. Use asyncio.Semaphore for rate limiting
  2. Implement error handling and retries
  3. Use connection pooling
  
  **Template:**
  ```python
  async def rate_limited_process(items, max_concurrent=10):
      semaphore = asyncio.Semaphore(max_concurrent)
      async with aiohttp.ClientSession() as session:
          async def process_with_limit(item):
              async with semaphore:
                  return await process_single_item(session, item)
          
          tasks = [process_with_limit(item) for item in items]
          return await asyncio.gather(*tasks)
  ```

**3. Connection Pooling**
- **Type:** `design_pattern`
- **Condition:** `connection_management`
- **Action:** `use_connection_pool`
- **Message:**
  When managing multiple connections:
  1. Use aiohttp.TCPConnector for connection pooling
  2. Set appropriate timeouts
  3. Implement proper cleanup
  
  **Template:**
  ```python
  async def setup_connection_pool(
      limit=100,
      ttl_dns_cache=300,
      timeout=30
  ):
      connector = aiohttp.TCPConnector(
          limit=limit,
          ttl_dns_cache=ttl_dns_cache
      )
      timeout = aiohttp.ClientTimeout(total=timeout)
      return aiohttp.ClientSession(
          connector=connector,
          timeout=timeout
      )
  ```

## Best Practices

1. **Error Handling:**
   - Always use try/except around async operations
   - Implement proper timeout handling
   - Use backoff for retries

2. **Resource Management:**
   - Use async context managers
   - Properly close sessions and connections
   - Implement proper cleanup in finally blocks

3. **Performance:**
   - Monitor memory usage with large batches
   - Implement proper rate limiting
   - Use connection pooling for efficiency

4. **Testing:**
   - Use pytest-asyncio for testing
   - Mock external services
   - Test timeout and error scenarios 